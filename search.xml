<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test2]]></title>
    <url>%2F2019%2F08%2F15%2Ftest2%2F</url>
    <content type="text"><![CDATA[test2]]></content>
  </entry>
  <entry>
    <title><![CDATA[基于glide框架的图片加载器简介]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%9F%BA%E4%BA%8Eglide%E6%A1%86%E6%9E%B6%E7%9A%84%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[背景 为什么选择Glide？http://blog.csdn.net/github_33304260/article/details/70213300 Glide直接能使用了，已经很方便了，为什么还要封装？ 入口统一，所有图片加载都在这一个地方管理，一目了然，即使有什么改动我也只需要改这一个类就可以了。 虽然现在的第三方库已经非常好用，但是如果我们看到第三方库就拿来用的话，很可能在第三方库无法满足业务需求或者停止维护的时候，发现替换库，工作量可见一斑。这就是不封装在切库时面临的窘境！ 外部表现一致，内部灵活处理原则 更多内容参考：如何正确使用开源项目？ Glide基本使用Glide使用一个流接口（Fluent Interface）。用Glide完成一个完整的图片加载功能请求，需要向其构造器中至少传入3个参数，分别是： with(Context context)- Context是许多Android API需要调用的， Glide也不例外。这里Glide非常方便，你可以任意传递一个Activity或者Fragment对象，它都可以自动提取出上下文。 load(String imageUrl) - 这里传入的是你要加载的图片的URL，大多数情况下这个String类型的变量会链接到一个网络图片。 into(ImageView targetImageView) - 将你所希望解析的图片传递给所要显示的ImageView。 example: 1234567ImageView targetImageView = (ImageView) findViewById(R.id.imageView);String internetUrl = &quot;http://i.imgur.com/DvpvklR.png&quot;;Glide .with(context) .load(internetUrl) .into(targetImageView); 常用API thumbnail(float sizeMultiplier). 请求给定系数的缩略图。如果缩略图比全尺寸图先加载完，就显示缩略图，否则就不显示。系数sizeMultiplier必须在(0,1)之间，可以递归调用该方法。 (DiskCacheStrategy strategy).设置缓存策略。&gt; -DiskCacheStrategy.SOURCE：缓存原始数据，DiskCacheStrategy.RESULT：缓存变换(如缩放、裁剪等)后的资源数据，DiskCacheStrategy.NONE：什么都不缓存，DiskCacheStrategy.ALL：缓存SOURC和RESULT。默认采用&gt; -&gt; -DiskCacheStrategy.RESULT策略，对于download only操作要使用&gt; -DiskCacheStrategy.SOURCE。 priority(Priority priority). 指定加载的优先级，优先级越高越优先加载，但不保证所有图片都按序加载。枚举Priority.IMMEDIATE，Priority.HIGH，Priority.NORMAL，Priority.LOW。默认为Priority.NORMAL。 dontAnimate() 移除所有的动画。 animate(int animationId). 在异步加载资源完成时会执行该动画。 animate(ViewPropertyAnimation.Animator animator). 在异步加载资源完成时会执行该动画。 animate(Animation animation). 在异步加载资源完成时会执行该动画。 placeholder(int resourceId). 设置资源加载过程中的占位Drawable。 error(int resourceId). 设置load失败时显示的Drawable。 skipMemoryCache(boolean skip). 设置是否跳过内存缓存，但不保证一定不被缓存（比如请求已经在加载资源且没设置跳过内存缓存，这个资源就会被缓存在内存中）。 override(int width, int height). 重新设置Target的宽高值（单位为pixel）。 into(Y target).设置资源将被加载到的Target。 into(ImageView view). 设置资源将被加载到的ImageView。取消该ImageView之前所有的加载并释放资源。 into(int width, int height). 后台线程加载时要加载资源的宽高值（单位为pixel）。 preload(int width, int height). 预加载resource到缓存中（单位为pixel）。 asBitmap(). 无论资源是不是gif动画，都作为Bitmap对待。如果是gif动画会停在第一帧。 asGif(). 把资源作为GifDrawable对待。如果资源不是gif动画将会失败，会回调.error()。 更多Glide详细介绍可以看Glide官网以及Glide教程系列文章 如何封装封装后的基本使用样式： 123456ImageLoader.with(this) .url(&quot;http://img.yxbao.com/news/image/201703/13/7bda462477.gif&quot;) .placeHolder(R.mipmap.ic_launcher,false) .rectRoundCorner(30, R.color.colorPrimary) .blur(40) .into(iv_round); 只需要关心ImageLoader就好了，就算里面封装的库更换、更新也没关系，因为对外的接口是不变的。实际操作中是由实现了ILoader的具体类去操作的，这里我们只封装了GlideLoader，其实所有操作都是由ImageLoader下发指令，由GlideLoader具体去实现的。这里如果想封装别的第三方库，只需要实现ILoader自己去完成里面的方法。 ##初始化 123456789101112131415161718192021222324public static int CACHE_IMAGE_SIZE = 250; public static void init(final Context context) &#123; init(context, CACHE_IMAGE_SIZE); &#125; public static void init(final Context context, int cacheSizeInM) &#123; init(context, cacheSizeInM, MemoryCategory.NORMAL); &#125; public static void init(final Context context, int cacheSizeInM, MemoryCategory memoryCategory) &#123; init(context, cacheSizeInM, memoryCategory, true); &#125; /** * @param context 上下文 * @param cacheSizeInM Glide默认磁盘缓存最大容量250MB * @param memoryCategory 调整内存缓存的大小 LOW(0.5f) ／ NORMAL(1f) ／ HIGH(1.5f); * @param isInternalCD true 磁盘缓存到应用的内部目录 / false 磁盘缓存到外部存 */ public static void init(final Context context, int cacheSizeInM, MemoryCategory memoryCategory, boolean isInternalCD) &#123; ImageLoader.context = context; GlobalConfig.init(context, cacheSizeInM, memoryCategory, isInternalCD); &#125; 从这里可以看出我们提供了四个构造器，这里注释详细说明了所有参数的用法及意义。 ##你所关心的类–ImageLoaderImageLoader是封装好所有的方法供用户使用的，让我们看看都有什么方法： ImageLoader.init(Context context) //初始化 ImageLoader.trimMemory(int level); ImageLoader.clearAllMemoryCaches(); ImageLoader.getActualLoader(); //获取当前的loader ImageLoader.with(Context context) //加载图片 ImageLoader.saveImageIntoGallery(String url) // 保存图片到相册 ImageLoader.pauseRequests() //取消请求 ImageLoader.resumeRequests() //回复的请求（当列表在滑动的时候，调用pauseRequests()取消请求，滑动停止时，调用resumeRequests()恢复请求 等等） ImageLoader.clearDiskCache()//清除磁盘缓存(必须在后台线程中调用) ImageLoader.clearMomoryCache(View view) //清除指定view的缓存 ImageLoader.clearMomory() // 清除内存缓存(必须在UI线程中调用) ##图片的各种设置信息–SingleConfig我们所设置图片的所有属性都写在这个类里面。下面我们详细的看一下： url(String url) //支持filepath、图片链接、contenProvider、资源id四种 thumbnail(float thumbnail)//缩略图 rectRoundCorner(int rectRoundRadius, int overlayColorWhenGif) //形状为圆角矩形时的圆角半径 asSquare() //形状为正方形 colorFilter(int color) //颜色滤镜 diskCacheStrategy(DiskCacheStrategy diskCacheStrategy) DiskCacheStrategy.ALL 使用DATA和RESOURCE缓存远程数据，仅使用RESOURCE来缓存本地数据。 DiskCacheStrategy.NONE 不使用磁盘缓存 DiskCacheStrategy.DATA 在资源解码前就将原始数据写入磁盘缓存 DiskCacheStrategy.RESOURCE 在资源解码后将数据写入磁盘缓存，即经过缩放等转换后的图片资源。 DiskCacheStrategy.AUTOMATIC 根据原始图片数据和资源编码策略来自动选择磁盘缓存策略。（默认） asCircle(int overlayColorWhenGif)//加载圆形图片 placeHolder(int placeHolderResId) //占位图 override(int oWidth, int oHeight) //加载图片时设置分辨率 a scale(int scaleMode) // CENTER_CROP等比例缩放图片，直到图片的狂高都大于等于ImageView的宽度，然后截取中间的显示 ; FIT_CENTER 等比例缩放图片，宽或者是高等于ImageView的宽或者是高 默认：FIT_CENTER animate(int animationId ) 引入动画 animate( Animation animation) 引入动画 animate(ViewPropertyAnimation.Animator animato) 引入动画 asBitmap(BitmapListener bitmapListener)// 使用bitmap不显示到imageview into(View targetView) //展示到imageview colorFilter(int filteColor) //颜色滤镜 blur(int blurRadius) ／/高斯模糊 brightnessFilter(float level) //调节图片亮度 grayscaleFilter() //黑白效果 swirlFilter() //漩涡效果 toonFilter() //油画效果 sepiaFilter() //水墨画效果 contrastFilter(float constrasrLevel) //锐化效果 invertFilter() //胶片效果 pixelationFilter(float pixelationLevel) //马赛克效果 sketchFilter() // //素描效果 vignetteFilter() //晕映效果 ##中转站–GlideLoaderGlideLoader实现ILoader接口。在使用的时候我们虽然不用关心这个类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288public class GlideLoader implements ILoader &#123; /** * @param context 上下文 * @param cacheSizeInM Glide默认磁盘缓存最大容量250MB * @param memoryCategory 调整内存缓存的大小 LOW(0.5f) ／ NORMAL(1f) ／ HIGH(1.5f); * @param isInternalCD true 磁盘缓存到应用的内部目录 / false 磁盘缓存到外部存 */ @Override public void init(Context context, int cacheSizeInM, MemoryCategory memoryCategory, boolean isInternalCD) &#123; Glide.get(context).setMemoryCategory(memoryCategory); //如果在应用当中想要调整内存缓存的大小，开发者可以通过如下方式： GlideBuilder builder = new GlideBuilder(); if (isInternalCD) &#123; builder.setDiskCache(new InternalCacheDiskCacheFactory(context, cacheSizeInM * 1024 * 1024)); &#125; else &#123; builder.setDiskCache(new ExternalPreferredCacheDiskCacheFactory(context, cacheSizeInM * 1024 * 1024)); &#125; &#125; @Override public void request(final SingleConfig config) &#123; RequestOptions requestOptions = getRequestOptions(config);//得到初始的 RequestOptions RequestBuilder requestBuilder = getRequestBuilder(config); //得到一个正确类型的 RequestBuilder(bitmap or 其他加载) if (requestBuilder == null) &#123; return; &#125; requestBuilder.apply(requestOptions);//应用RequestOptions //设置缩略图 if (config.getThumbnail() != 0) &#123; //设置缩略比例 requestBuilder.thumbnail(config.getThumbnail()); &#125; //设置图片加载动画 setAnimator(config, requestBuilder); if (config.isAsBitmap()) &#123;//如果是获取bitmap,则回调 SimpleTarget target = new SimpleTarget&lt;Bitmap&gt;(config.getWidth(), config.getHeight()) &#123; @Override public void onResourceReady(@NonNull Bitmap resource, @Nullable Transition&lt;? super Bitmap&gt; transition) &#123; if (config.getBitmapListener() != null) &#123; config.getBitmapListener().onSuccess(resource); &#125; &#125; &#125;; requestBuilder.into(target); &#125; else &#123;//如果是加载图片，（无论是否为Gif） if (config.getTarget() instanceof ImageView) &#123; requestBuilder.into((ImageView) config.getTarget()); &#125; &#125; &#125; private RequestOptions getRequestOptions(SingleConfig config) &#123; RequestOptions options = new RequestOptions(); //设置磁盘缓存 if (config.getDiskCacheStrategy() != null) &#123; options.diskCacheStrategy(config.getDiskCacheStrategy()); &#125;else&#123; options.diskCacheStrategy(DiskCacheStrategy.AUTOMATIC);//默认为自动选择 &#125; if (ImageUtil.shouldSetPlaceHolder(config)) &#123; options = options.placeholder(config.getPlaceHolderResId()); &#125; int scaleMode = config.getScaleMode(); switch (scaleMode) &#123; case ScaleMode.CENTER_CROP: options.centerCrop(); break; case ScaleMode.FIT_CENTER: options.fitCenter(); break; default: options.fitCenter(); break; &#125; //设置图片加载的分辨 sp if (config.getoWidth() != 0 &amp;&amp; config.getoHeight() != 0) &#123; options.override(config.getoWidth(), config.getoHeight()); &#125; //设置图片加载优先级 setPriority(config, options); if (config.getErrorResId() &gt; 0) &#123; options.error(config.getErrorResId()); &#125; setShapeModeAndBlur(config, options);//设置RequestOptions 关于 多重变换 return options; &#125; /** * 设置加载优先级 * * @param config * @param options */ private void setPriority(SingleConfig config, RequestOptions options) &#123; switch (config.getPriority()) &#123; case PriorityMode.PRIORITY_LOW: options.priority(Priority.LOW); break; case PriorityMode.PRIORITY_NORMAL: options.priority(Priority.NORMAL); break; case PriorityMode.PRIORITY_HIGH: options.priority(Priority.HIGH); break; case PriorityMode.PRIORITY_IMMEDIATE: options.priority(Priority.IMMEDIATE); break; default: options.priority(Priority.IMMEDIATE); break; &#125; &#125; /** * 设置加载进入动画 * * @param config * @param request */ private void setAnimator(SingleConfig config, RequestBuilder request) &#123; if (config.getAnimationType() == AnimationMode.ANIMATIONID) &#123; GenericTransitionOptions genericTransitionOptions = GenericTransitionOptions.with(config.getAnimationId()); request.transition(genericTransitionOptions); &#125; else if (config.getAnimationType() == AnimationMode.ANIMATOR) &#123; GenericTransitionOptions genericTransitionOptions = GenericTransitionOptions.with(config.getAnimator()); request.transition(genericTransitionOptions); &#125; else if (config.getAnimationType() == AnimationMode.ANIMATION) &#123; GenericTransitionOptions genericTransitionOptions = GenericTransitionOptions.with(new ViewAnimationFactory(config.getAnimation())); request.transition(genericTransitionOptions); &#125; else &#123;//设置默认的交叉淡入动画 request.transition(DrawableTransitionOptions.withCrossFade()); &#125; &#125; @Nullable private RequestBuilder getRequestBuilder(SingleConfig config) &#123; RequestManager requestManager = Glide.with(config.getContext()); RequestBuilder request = null; if (config.isAsBitmap()) &#123; request = requestManager.asBitmap(); &#125; else if (config.isGif()) &#123; request = requestManager.asGif(); &#125; else &#123; request = requestManager.asDrawable(); &#125; if (!TextUtils.isEmpty(config.getUrl())) &#123; request.load(ImageUtil.appendUrl(config.getUrl())); Log.e(&quot;TAG&quot;, &quot;getUrl : &quot; + config.getUrl()); &#125; else if (!TextUtils.isEmpty(config.getFilePath())) &#123; request.load(ImageUtil.appendUrl(config.getFilePath())); Log.e(&quot;TAG&quot;, &quot;getFilePath : &quot; + config.getFilePath()); &#125; else if (!TextUtils.isEmpty(config.getContentProvider())) &#123; request.load(Uri.parse(config.getContentProvider())); Log.e(&quot;TAG&quot;, &quot;getContentProvider : &quot; + config.getContentProvider()); &#125; else if (config.getResId() &gt; 0) &#123; request.load(config.getResId()); Log.e(&quot;TAG&quot;, &quot;getResId : &quot; + config.getResId()); &#125; else if (config.getFile() != null) &#123; request.load(config.getFile()); Log.e(&quot;TAG&quot;, &quot;getFile : &quot; + config.getFile()); &#125; else if (!TextUtils.isEmpty(config.getAssertspath())) &#123; request.load(config.getAssertspath()); Log.e(&quot;TAG&quot;, &quot;getAssertspath : &quot; + config.getAssertspath()); &#125; else if (!TextUtils.isEmpty(config.getRawPath())) &#123; request.load(config.getRawPath()); Log.e(&quot;TAG&quot;, &quot;getRawPath : &quot; + config.getRawPath()); &#125; return request; &#125; /** * 设置图片滤镜和形状 * * @param config * @param options */ private void setShapeModeAndBlur(SingleConfig config, RequestOptions options) &#123; int count = 0; Transformation[] transformation = new Transformation[statisticsCount(config)]; if (config.isNeedBlur()) &#123; transformation[count] = new BlurTransformation(config.getBlurRadius()); count++; &#125; if (config.isNeedBrightness()) &#123; transformation[count] = new BrightnessFilterTransformation(config.getBrightnessLeve()); //亮度 count++; &#125; if (config.isNeedGrayscale()) &#123; transformation[count] = new GrayscaleTransformation(); //黑白效果 count++; &#125; if (config.isNeedFilteColor()) &#123; transformation[count] = new ColorFilterTransformation(config.getFilteColor()); count++; &#125; if (config.isNeedSwirl()) &#123; transformation[count] = new SwirlFilterTransformation(0.5f, 1.0f, new PointF(0.5f, 0.5f)); //漩涡 count++; &#125; if (config.isNeedToon()) &#123; transformation[count] = new ToonFilterTransformation(); //油画 count++; &#125; if (config.isNeedSepia()) &#123; transformation[count] = new SepiaFilterTransformation(); //墨画 count++; &#125; if (config.isNeedContrast()) &#123; transformation[count] = new ContrastFilterTransformation(config.getContrastLevel()); //锐化 count++; &#125; if (config.isNeedInvert()) &#123; transformation[count] = new InvertFilterTransformation(); //胶片 count++; &#125; if (config.isNeedPixelation()) &#123; transformation[count] = new PixelationFilterTransformation(config.getPixelationLevel()); //马赛克 count++; &#125; if (config.isNeedSketch()) &#123; transformation[count] = new SketchFilterTransformation(); //素描 count++; &#125; if (config.isNeedVignette()) &#123; transformation[count] = new VignetteFilterTransformation(new PointF(0.5f, 0.5f), new float[]&#123;0.0f, 0.0f, 0.0f&#125;, 0f, 0.75f);//晕映 count++; &#125; switch (config.getShapeMode()) &#123; case ShapeMode.RECT: break; case ShapeMode.RECT_ROUND: transformation[count] = new RoundedCornersTransformation (config.getRectRoundRadius(), 0, RoundedCornersTransformation.CornerType.ALL); count++; break; case ShapeMode.OVAL://@deprecated Use &#123;@link RequestOptions#circleCrop()&#125;.// transformation[count] = new CropCircleTransformation();// count++; options = options.circleCrop(); break; case ShapeMode.SQUARE: transformation[count] = new CropSquareTransformation(); count++; break; &#125; if (transformation.length != 0) &#123; options.transforms(transformation); &#125; &#125; ... &#125;]]></content>
      <categories>
        <category>android技术文档</category>
      </categories>
      <tags>
        <tag>android技术文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目MVVM结构简析]]></title>
    <url>%2F2018%2F07%2F26%2F%E9%A1%B9%E7%9B%AEMVVM%E7%BB%93%E6%9E%84%E7%AE%80%E6%9E%90%2F</url>
    <content type="text"><![CDATA[MVVM框架google官方发布了MVVM的正式库。官方的正式MVVM库主要包括下面四个： 其中只有ViewModel是MVVM结构中的一个组件，其他的三个都是辅助性质的。lifecycles 就是处理UI界面的生命周期，在26版本以后的Support库中，AppCompatActivity和SupportActivity中都实现了LifecycleOwner，内部已经对UI界面的生命周期做了处理了。LiveData是一个抽象类，我们可以存放UI页面需要的数据，就是把数据包装在LiveData中了，我们可以观测LiveData中的数据变化，但是LiveData是跟UI的生命周期关联的，当UI页面销毁了，LiveData的数据变化回调是不会执行的。Room 就是一个sqlite数据持久化库，我们也可以使用别的ORM库。 MVVM架构优势一张图看看MVVM: 看上图Model和View是不会发生关系的，ViewModel是把View和Model关联起来的. View和Model双向绑定，一方的改变都会影响另一方，开发者不用再去手动修改UI的数据。互相自动更新。 View和Model的双向绑定是支持生命周期检测的，不会担心页面销毁了还有回调发生，这个由lifeCycle完成。 不会像MVC一样Activity中代码量巨大，也不会像MVP一样出现大量的View和Presenter接口。项目结构更加低耦合。 更低的耦合把各个模块分开开发，分开测试，可以分给不同的开发人员来完成。 MVVM项目架构分析项目整体架构如官方下图架构： 下图是项目模块和工程之间的依赖关系： ARouter串联各个模块使用ARouter来跳转Activity和获取Fragment. ARouter常见的应用场景 从外部URL映射到内部页面，以及参数传递与解析 跨模块页面跳转，模块间解耦 拦截跳转过程，处理登陆、埋点等逻辑(添加拦截器的方法是利用Interceptor注解，实现IInterceptor接口) 跨模块API调用，通过控制反转来做组件解耦 Api常用方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 构建标准的路由请求ARouter.getInstance().build(&quot;/home/main&quot;).navigation();// 构建标准的路由请求，并指定分组ARouter.getInstance().build(&quot;/home/main&quot;, &quot;ap&quot;).navigation();// 构建标准的路由请求，通过Uri直接解析Uri uri;ARouter.getInstance().build(uri).navigation();// 构建标准的路由请求，startActivityForResult// navigation的第一个参数必须是Activity，第二个参数则是RequestCodeARouter.getInstance().build(&quot;/home/main&quot;, &quot;ap&quot;).navigation(this, 5);// 直接传递BundleBundle params = new Bundle();ARouter.getInstance() .build(&quot;/home/main&quot;) .with(params) .navigation();// 指定FlagARouter.getInstance() .build(&quot;/home/main&quot;) .withFlags(); .navigation();// 获取FragmentFragment fragment = (Fragment) ARouter.getInstance().build(&quot;/test/fragment&quot;).navigation();// 对象传递ARouter.getInstance() .withObject(&quot;key&quot;, new TestObj(&quot;Jack&quot;, &quot;Rose&quot;)) .navigation();// 觉得接口不够多，可以直接拿出Bundle赋值ARouter.getInstance() .build(&quot;/home/main&quot;) .getExtra();// 转场动画(常规方式)ARouter.getInstance() .build(&quot;/test/activity2&quot;) .withTransition(R.anim.slide_in_bottom, R.anim.slide_out_bottom) .navigation(this);// 转场动画(API16+)ActivityOptionsCompat compat = ActivityOptionsCompat. makeScaleUpAnimation(v, v.getWidth() / 2, v.getHeight() / 2, 0, 0);// makeSceneTransitionAnimation 使用共享元素的时候，需要在navigation方法中传入当前ActivityARouter.getInstance() .build(&quot;/test/activity2&quot;) .withOptionsCompat(compat) .navigation();// 使用绿色通道(跳过所有的拦截器)ARouter.getInstance().build(&quot;/home/main&quot;).greenChannel().navigation();// 使用自己的日志工具打印日志ARouter.setLogger();//获取原始的URIString uriStr = getIntent().getStringExtra(ARouter.RAW_URI);//关闭ARouterARouter.getInstance().destroy(); 组件化编译和非组件化编译切换在工程根目录下的gradle.properties文件中加入一个Boolean类型的变量，通过修改这个变量来识别编译模式：123# 每次更改“isBuildModule”的值后，需要点击 &quot;Sync Project&quot; 按钮# isBuildModule“集成开发模式”和“组件开发模式”的切换开关isBuildModule=false 然后在 各个module中的build.gradle文件中支持切换：示例:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859if (isBuildModule.toBoolean()) &#123; apply plugin: &apos;com.android.application&apos;&#125; else &#123; apply plugin: &apos;com.android.library&apos;&#125;android &#123; compileSdkVersion parent.ext.compileSdkVersion buildToolsVersion parent.ext.buildToolsVersion sourceSets &#123; main &#123; if (isBuildModule.toBoolean()) &#123; manifest.srcFile &apos;src/main/debug/AndroidManifest.xml&apos; &#125; else &#123; manifest.srcFile &apos;src/main/release/AndroidManifest.xml&apos; &#125; &#125; &#125; if (isBuildModule.toBoolean()) &#123; packagingOptions &#123; exclude &apos;META-INF/LICENSE&apos; exclude &apos;META-INF/NOTICE&apos; exclude &apos;META-INF/DEPENDENCIES&apos; &#125; &#125; defaultConfig &#123; if (isBuildModule.toBoolean()) &#123; applicationId &quot;base.android.t3t.netrequestdemo&quot; &#125; minSdkVersion 14 targetSdkVersion 27 versionCode 1 versionName &quot;1.0&quot; javaCompileOptions &#123; annotationProcessorOptions &#123; arguments = [moduleName: project.getName()] &#125; &#125; &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; &#125; &#125;&#125;dependencies &#123; implementation fileTree(dir: &apos;libs&apos;, include: [&apos;*.jar&apos;]) implementation project(&apos;:basebusinesslib&apos;) annotationProcessor &quot;com.alibaba:arouter-compiler:$arouter_compiler_version&quot;&#125;]]></content>
      <tags>
        <tag>android技术文档</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux介绍]]></title>
    <url>%2F2018%2F07%2F10%2Fredux-introduction-00%2F</url>
    <content type="text"><![CDATA[何时使用 Redux？需要明确一点，Redux 是一个有用的架构，但不是非用不可。事实上，大多数情况，你可以不用它，只用 React 就够了。 React 早期贡献者之一 Pete Hunt 说： 你应当清楚何时需要 Flux。如果你不确定是否需要它，那么其实你并不需要它。 Redux 的创建者之一 Dan Abramov 也曾表达过类似的意思: 我想修正一个观点：当你在使用 React 遇到问题时，才使用 Redux。 简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。 用户的使用方式非常简单 用户之间没有协作 不需要与服务器大量交互，也没有使用 WebSocket 视图层（View）只从单一来源获取数据 上面这些情况，都不需要使用 Redux。 用户的使用方式复杂 不同身份的用户有不同的使用方式（比如普通用户和管理员） 多个用户之间可以协作 与服务器大量交互，或者使用了WebSocket View要从多个来源获取数据 上面这些情况才是 Redux 的适用场景：多交互、多数据源。 从组件角度看，如果你的应用有以下场景，可以考虑使用 Redux。 某个组件的状态，需要共享 某个状态需要在任何地方都可以拿到 一个组件需要改变全局状态 一个组件需要改变另一个组件的状态 发生上面情况时，如果不使用 Redux 或者其他状态管理工具，不按照一定规律处理状态的读写，代码很快就会变成一团乱麻。你需要一种机制，可以在同一个地方查询状态、改变状态、传播状态的变化。 最后需要说明的是：Redux 仅仅是个工具。它是一个伟大的工具，经常有一个很棒的理由去使用它，但也有很多的理由不去使用它。时刻注意对你的工具做出明确的决策，并且权衡每个决策带来的利弊。 Redux是什么？Redux是JavaScript状态容器，能提供可预测化的状态管理。 它认为： Web应用是一个状态机，视图与状态是一一对应的。 所有的状态，保存在一个对象里面。 我们先来看看“状态容器”、“视图与状态一一对应”以及“一个对象”这三个概念的具体体现。 如上图，Store是Redux中的状态容器，它里面存储着所有的状态数据，每个状态都跟一个视图一一对应。 Redux也规定，一个State对应一个View。只要State相同，View就相同，知道了State，就知道View是什么样，反之亦然。 比如，当前页面分三种状态：loading（加载中）、success（加载成功）或者error（加载失败），那么这三个就分别唯一对应着一种视图。 现在我们对“状态容器”以及“视图与状态一一对应”有所了解了，那么Redux是怎么实现可预测化的呢？我们再来看下Redux的工作流程。 首先，我们看下几个核心概念： Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。 State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这种时点的数据集合，就叫做State。 Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到View。所以，State的变化必须是View导致的。Action就是View发出的通知，表示State应该要发生变化了。 Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，所以我们定义一个函数来生成Action，这个函数就叫Action Creator。 Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。 dispatch：是View发出Action的唯一方法。 然后我们过下整个工作流程： 首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。 然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State State一旦有变化，Store就会调用监听函数，来更新View。 到这儿为止，一次用户交互流程结束。可以看到，在整个流程中数据都是单向流动的，这种方式保证了流程的清晰。 为什么要用Redux？前端复杂性的根本原因是大量无规律的交互和异步操作。 变化和异步操作的相同作用都是改变了当前View的状态，但是它们的无规律性导致了前端的复杂，而且随着代码量越来越大，我们要维护的状态也越来越多。 我们很容易就对这些状态何时发生、为什么发生以及怎么发生的失去控制。那么怎样才能让这些状态变化能被我们预先掌握，可以复制追踪呢？ 这就是Redux设计的动机所在。 Redux试图让每个State变化都是可预测的，将应用中所有的动作与状态都统一管理，让一切有据可循。 如上图所示，如果我们的页面比较复杂，又没有用任何数据层框架的话，就是图片上这个样子：交互上存在父子、子父、兄弟组件间通信，数据也存在跨层、反向的数据流。 这样的话，我们维护起来就会特别困难，那么我们理想的应用状态是什么样呢？看下图： 架构层面上讲，我们希望UI跟数据和逻辑分离，UI只负责渲染，业务和逻辑交由其它部分处理，从数据流向方面来说, 单向数据流确保了整个流程清晰。 我们之前的操作可以复制、追踪出来，这也是Redux的主要设计思想。 综上，Redux可以做到： 每个State变化可预测。 动作与状态统一管理。 redux与react-redux关系图 参考资料Redux中文文档 美团技术团队-Redux从设计到源码 阮一峰Redux相关文章]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
        <tag>React</tag>
        <tag>状态管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rxjava 2.x基础入门]]></title>
    <url>%2F2018%2F07%2F04%2F2-x%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[背景 提及Rxjava之前，了解下响应式编程，它的英文名，Reactive Programming，字面意思就是针对响应的。那什么是叫响应呢？（eg：门铃响了，你会起身去开门，这就是响应）响应式它是依赖于事件的，响应式的代码它的运行不是按代码的顺序，而是跟多个按时间发生的事件有关。依赖事件？不就是“回调”？，but在响应式编程里，这些按时间排列的事件，被称为“流”，stream。没有流stream，就没有响应式编程。一句概括的话，响应式编程就是通过异步和数据流来构建事物关系的编程模型，就是编程处理异步数据流。 目前的情况，Android 的网络库基本被 Retrofit + OkHttp 一统天下了，而配合上响应式编程 RxJava 可谓如鱼得水。 RxJava 是什么git地址 RxJava is a Java VM implementation of Reactive Extensions: a library for composing asynchronous and event-based programs by using observable sequences. 它的本质可以压缩为异步。归根结底，它就是一个实现异步操作的库，加粗的部分都是修饰Rxjava。 It extends the observer pattern to support sequences of data/events and adds operators that allow you to compose sequences together declaratively while abstracting away concerns about things like low-level threading, synchronization, thread-safety and concurrent data structures. 它扩展了观察者模式支持的数据/事件序列,使用操作符来将这些数据/事件进行调整序列,不用担忧无关的抽象底层线程,同步,线程安全和并发数据结问题。 RxJava 优势 不用担忧无关的抽象底层线程,同步,线程安全和并发数据结问题。 简洁 异步操作很关键的一点是程序的简洁性，因为在调度过程比较复杂的情况下，异步代码经常会既难写也难被读懂。 Android sdk里面的 AsyncTask 和Handler ，其实都是为了让异步代码更加简洁。RxJava 的优势也是简洁，但它的简洁的与众不同之处在于，随着程序逻辑变得越来越复杂，它依然能够保持简洁。(code从上到下的链式调用，没有任何嵌套，逻辑清晰，可阅读性强)； 代码示例： 1234567Observable obserInitSDK=Observable.create((context)-&gt;&#123;initDevUtils(context);&#125;).subscribeOn(Schedulers.newThread());Observable obserInitDB=Observable.create((context)-&gt;&#123;initDatabase(context);&#125;).subscribeOn(Schedulers.newThread());Observable observable = Observable.merge(obserInitSDK,obserInitDB);observable.subscribe(()-&gt;&#123;JumpToMain();&#125;); 可以解决的问题：让复杂的程序逻辑回归简单、清晰。 API 简析上面实际已经提到 RxJava 的异步实现，是通过一种扩展的观察者模式来实现的。 RxJava的被观察者为观察者模式添加两个功能。 当不再产生数据时，生产者会通知消费者。（onComplete()） 当发生错误时，生产者会通知消费者。（onError()） 除此之外，RxJava的两点在于几行代码就可以变换，聚合，过滤被观察者发送的数据流，极大的减少需要维护的状态变量。简单来说Rxjava原理就是使用”观察者模式+迭代器模式+函数式编程”，它扩展了观察者模式，通过使用可观察的对象序列流来表述一系列事件，订阅者进行占点观察并对序列流做出反应（或持久化或输出显示等等）；借鉴迭代器模式，对多个对象序列进行迭代输出，订阅者可以依次处理不同的对象序列；使用函数式编程思想，极大简化问题解决的步骤。 RxJava 有四个基本概念： Observable/Flowable (可观察者，即被观察者) Observer/Subscriber (观察者) subscribe (订阅),被观察者(Observable/Flowable) 观察者(Observer/Subscriber) 通过 subscribe() 方法实现订阅关系这样被观察者(Observable/Flowable) 可以在需要的时候发出事件来通知 观察者(Observer/Subscriber)。 所以使用RxJava 的三个步骤： 第一步：初始化 bservable/Flowable (可观察者，即被观察者) 第二部步：初始化 Observer/Subscriber (观察者) 第三步：建立订阅关系 代码示例： 创建观察者 12345678910111213141516171819202122 Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onSubscribe(Disposable d) &#123; //Disposable d可用来中止观察 d.dispose(); &#125; @Override public void onNext(String s) &#123; Log.d(&quot;dale&quot;, &quot;Item: &quot; + s); &#125; @Override public void onError(Throwable e) &#123; Log.d(&quot;dale&quot;, &quot;onError!&quot;); &#125; @Override public void onComplete() &#123; Log.d(&quot;dale&quot;, &quot;onComplete!&quot;); &#125;&#125;; 创建被观察者有很多种方法 具体参考 Rxjava中文翻译文档 Rxjava文档 1234567//被观察者 Observable observable = Observable.create(new ObservableOnSubscribe&lt;String&gt;() &#123; @Override public void subscribe(ObservableEmitter&lt;String&gt; e) throws Exception &#123; e.onNext(&quot;send msg&quot;); &#125;&#125;); 将观察者连接到被观察者(订阅)：被观察者是惰性的，在没有订阅者监听之前它不会做任何事情。 1observable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(observer); 操作符 Rxjava有很多实用的操作符，详细文档见中文翻译文档，也可以直接看官方文档。下面结合场景使用比较常用的几个操作符。Rxjava官方wiki 改变流：Filter：Filter运算符会过滤被观察者，被观察者发射的数据中只有通过你在谓词函数中指定的测试后才能继续往下流动。 12345678910111213141516private ArrayList&lt;String&gt; originData = new ArrayList&lt;String&gt;() &#123;&#123; add(&quot;11&quot;); add(&quot;1111&quot;); &#125;&#125;; Observable.fromIterable(originData) .filter(new Predicate&lt;String&gt;() &#123; @Override public boolean test(String item) throws Exception &#123; return item.length() &gt; 2; &#125; &#125;).subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String dst) throws Exception &#123; //过滤出符合自己要求的数据 &#125; &#125;); 上面的代码就是过滤出集合里字符串长度大于2的字符串。应用场景，实际应用开发过滤数据还是很多的。 转换流：map: 可以将一个 Observable 对象通过某种关系转换为另一个Observable 对象。 1234567891011121314Flowable.just(&quot;xxxxxxx&quot;) //这个第一个泛型为接收参数的数据类型，第二个泛型为转换后要发射的数据类型 .map(new Function&lt;String, String&gt;() &#123; @Override public String apply(String s) throws Exception &#123; return s+&quot;__uuuuuuu&quot;; &#125; &#125;) .subscribe(new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) throws Exception &#123; Log.e(&quot;consumer&quot;, s); &#125; &#125;); 例子中map()将一个字符串对象，转换为另一个字符串对象返回，当然也可以将其转换为与之不同的对象，对应的返回的Flowable对象参数也会变为转换后的对象。另外Function的泛型第一个为接收参数的数据类型，第二个为转换后要发射的数据类型。应用场景，map 操作符进行网络数据解析，数据库读取数据解析，改变数据对象属性 等等。 线程调度 线程调度器，方便更好的处理异步操作，在合适的场景选择合适的线程. RxJava 中，已经内置了很多线程选项： Schedulers.immediate(): 直接在当前线程运行，相当于不指定线程。这是默认的 Scheduler。 Schedulers.newThread(): 总是启用新线程，并在新线程执行操作。 Schedulers.io(): I/O 操作（读写文件、读写数据库、网络信息交互等）所使用的 Scheduler。行为模式和 newThread() 差不多，区别在于 io() 的内部实现是用一个无数量上限的线程池，可以重用空闲的线程，因此多数情况下 io() 比 newThread() 更有效率。不要把计算工作放在 io() 中，可以避免创建不必要的线程。 Schedulers.computation(): 计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU。 AndroidSchedulers.mainThread(): Android 还专用的,它指定的操作将在 Android 主线程运行。 通过这几个 Scheduler ，就可以使用 subscribeOn() 和 observeOn() 两个方法来对线程进行控制了。 subscribeOn(): 指定Observable(被观察者)所在的线程，或者叫做事件产生的线程。 observeOn(): 指定 Observer(观察者)所运行在的线程，或者叫做事件消费的线程。 Flowabale的使用,以及RxJava 2.x中的backpressure的处理策略。Flowable的产生在RxJava中会经常遇到一种情况就是被观察者发送消息十分迅速以至于观察者不能及时的响应这些消息。被观察者是事件的生产者，观察者是事件的消费者，比如生产者无限生成事件，而消费者每2秒才能消费一个事件，这会造成事件无限堆积，最后造成OOM。 因此问题来了，怎么处理这些慢慢堆积起来的消息呢？Flowable就是由此产生，专门用来处理这类问题。关于上述的问题，有个专有的名词来形容上述现象，即：Backpressure(背压)。所谓背压，即生产者的速度大于消费者的速度带来的问题。 Flowable是为了应对Backpressure而产生的。Flowable是一个被观察者，与Subscriber(观察者)配合使用，解决Backpressure问题。 注意理解：处理Backpressure的策略仅仅是处理Subscriber接收事件的方式，并不影响Flowable发送事件的方法。即使采用了处理Backpressure的策略，Flowable原来以什么样的速度产生事件，现在还是什么样的速度不会变化，主要处理的是Subscriber接收事件的方式。 处理Backpressure的策略什么情况下才会产生Backpressure问题？ 如果生产者和消费者在一个线程的情况下，无论生产者的生产速度有多快，每生产一个事件都会通知消费者，等待消费者消费完毕，再生产下一个事件。所以在这种情况下，根本不存在Backpressure问题。即同步情况下，Backpressure问题不存在。 如果生产者和消费者不在同一线程的情况下，如果生产者的速度大于消费者的速度，就会产生Backpressure问题。即异步情况下，Backpressure问题才会存在。 ERROR策略这种方式会产生背压的时候直接throw一个异常MissingBackpressureException.1234567891011121314151617181920212223242526272829303132333435Flowable&lt;Integer&gt; flowable = Flowable.create(new FlowableOnSubscribe&lt;Integer&gt;() &#123; @Override public void subscribe(FlowableEmitter&lt;Integer&gt; emitter) throws Exception &#123; Log.d(TAG, &quot;emit 1&quot;); emitter.onNext(1); Log.d(TAG, &quot;emit 2&quot;); emitter.onNext(2); Log.d(TAG, &quot;emit 3&quot;); emitter.onNext(3); Log.d(TAG, &quot;emit complete&quot;); emitter.onComplete(); &#125; &#125;, BackpressureStrategy.ERROR); //增加了一个参数 Subscriber&lt;Integer&gt; subscriber = new Subscriber&lt;Integer&gt;() &#123; @Override public void onSubscribe(Subscription s) &#123; Log.d(TAG, &quot;onSubscribe&quot;); s.request(20); //可以消费的事件数量 &#125; @Override public void onNext(Integer integer) &#123; Log.d(TAG, &quot;onNext: &quot; + integer); &#125; @Override public void onError(Throwable t) &#123; Log.w(TAG, &quot;onError: &quot;, t); &#125; @Override public void onComplete() &#123; Log.d(TAG, &quot;onComplete&quot;); &#125; &#125;; flowable.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()).subscribe(subscriber); 代码创建了一个Flowable(被观察者)和一个Subscriber(观察者)，不同的是 onSubscribe(Subscription s)中传给我们的不再是Disposable了, 而是Subscription。然而Subscription也可以用于切断观察者与被观察者之间的联系，调用Subscription.cancel()方法便可。 不同的地方在于Subscription增加了一个void request(long n)方法, 示例代码加入了s.request(20); 该方法就是用来向生产者申请可以消费的事件数量。这样我们便可以根据本身的消费能力进行消费事件。当调用了request()方法后，生产者便发送对应数量的事件供消费者消费。因为Flowable在设计的时候采用了一种新的思路也就是响应式拉取的方式,要求多少，给你多少。 注意：如果不显示调用request就表示消费能力为0。 虽然并不限制向request()方法中传入任意数字，但是如果消费者并没有这么多的消费能力，依旧会造成资源浪费，最后产生OOM。所以ERROR策略就避免了这种情况的出现。在异步调用时，RxJava中有个缓存池，用来缓存消费者处理不了暂时缓存下来的数据，缓存池的默认大小为128，即只能缓存128个事件。无论request()中传入的数字比128大或小，缓存池中在刚开始都会存入128个事件。当然如果本身并没有这么多事件需要发送，则不会存128个事件。在ERROR策略下，如果缓存池溢出，就会立刻抛出MissingBackpressureException异常。ERROR即保证在异步操作中，事件累积不能超过128，超过即出现异常。消费者不能再接收事件了，但生产者并不会停止。 BUFFER策略所谓BUFFER就是把RxJava中默认的只能存128个事件的缓存池换成一个大的缓存池，支持存很多很多的数据。这样，消费者通过request()即使传入一个很大的数字，生产者也会生产事件，并将处理不了的事件缓存。但是这种方式任然比较消耗内存，除非是我们比较了解消费者的消费能力，能够把握具体情况，不会产生OOM。总之BUFFER要慎用。 DROP策略当消费者处理不了事件，就丢弃。消费者通过request()传入其需求n，然生产者把n个事件传递给消费者供其消费。其他消费不掉的事件就丢掉。 LATEST策略LATEST与DROP功能基本一致。消费者通过request()传入其需求n，然后生产者把n个事件传递给消费者供其消费。其他消费不掉的事件就丢掉。唯一的区别就是LATEST总能使消费者能够接收到生产者产生的最后一个事件。 Flowable对象的获取通过create()方式，使用BackpressureStrategy.LATEST之类的方式指定处理背压的策略。如果Flowable对象不是自己创建的，可以采用onBackpressureBuffer()、onBackpressureDrop()、onBackpressureLatest()的方式指定。示例代码:123456789Flowable.just(1).onBackpressureBuffer() .observeOn(AndroidSchedulers.mainThread()) .subscribeOn(Schedulers.io()) .subscribe(new Consumer&lt;Integer&gt;() &#123; @Override public void accept(Integer integer) throws Exception &#123; &#125; &#125;); Rxjava中文翻译文档Rxjava文档]]></content>
      <categories>
        <category>android技术文档</category>
      </categories>
      <tags>
        <tag>Rxjava rxjava</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android架构组件——ViewModel]]></title>
    <url>%2F2018%2F07%2F02%2FAndroid%E6%9E%B6%E6%9E%84%E7%BB%84%E4%BB%B6%E2%80%94%E2%80%94ViewModel%2F</url>
    <content type="text"><![CDATA[概述Android 官方架构组件在2017年11月份Android官方架构组件正式版发布, 并且 Google 也在 Support Library v26.1.0 以后的版本中内嵌了 Android 官方架构组件中的生命周期组件. 生命周期 ViewModel是UI相关数据管理类。但不是数据持有类最为重要的就是ViewModel具有下面的生命周期： 上图是用Activity作为例子，左侧表示Activity的生命周期状态，右侧绿色部分表示ViewModel的生命周期范围。当屏幕旋转的时候，Activity会被recreate，Activity会经过几个生命周期方法，但是这个时候ViewModel还是之前的对象，并没有被重新创建，只有当Activity的finish()方法被调用时，ViewModel.onCleared()方法会被调用，对象才会被销毁。这张图很好的描述了是当Activity被recreate时，ViewModel的生命周期。注意：在ViewModel中不要持有Activity的引用。从上面的图我们看到，当Activity被recreate时，ViewModel对象并没有被销毁，如果Model持有Activity的引用时就可能会导致内存泄漏。那如果你要使用到Context对象，建议使用ViewModel的子类AndroidViewModel或者你自己传入application的上下文。 正因为ViewModel有如此的生命周期，所以ViewModel在MVVM可以作为数据管理，是连接View和Model重要组件，ViewModel的核心作用如下图所示： ViewModel简析ViewModel的基本使用方法，我们在获取ViewModel的时候绝对不能直接使用new关键字去创建，需要使用 ViewModelProviders 去使用系统提供的反射方法去创建我们想要的ViewModel，下面是官方架构组件android.arch.lifecycle包下面的ViewModelProviders工具类用来获取ViewModel: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class ViewModelProviders &#123; /** * 通过Activity获取可用的Application * 或者检测Activity是否可用 * @param activity * @return */ private static Application checkApplication(Activity activity) &#123; Application application = activity.getApplication(); if (application == null) &#123; throw new IllegalStateException(&quot;Your activity/fragment is not yet attached to &quot; + &quot;Application. You can&apos;t request ViewModel before onCreate call.&quot;); &#125; return application; &#125; /** * 通过Fragment获取Activity * 或者检测Fragment是否可用 * @param fragment * @return */ private static Activity checkActivity(Fragment fragment) &#123; Activity activity = fragment.getActivity(); if (activity == null) &#123; throw new IllegalStateException(&quot;Can&apos;t create ViewModelProvider for detached fragment&quot;); &#125; return activity; &#125; /** * 通过Fragment获得ViewModelProvider * @param fragment * @return */ @NonNull @MainThread public static ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory) &#123; Application application = checkApplication(checkActivity(fragment)); if (factory == null) &#123; /**获取默认的单例AndroidViewModelFactory，它内部是通过反射来创建具体的ViewModel*/ factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; /*** * 利用HolderFragment来关联生命周期并使用HolderFragment中的ViewModelStore的HashMap存储ViewModel * AndroidViewModelFactory创建ViewModel */ return new ViewModelProvider(ViewModelStores.of(fragment), factory); &#125; /** * 通过FragmentActivity获得ViewModelProvider * @param activity * @return */ @NonNull @MainThread public static ViewModelProvider of(@NonNull FragmentActivity activity, @Nullable Factory factory) &#123; Application application = checkApplication(activity); /**获取默认的单例AndroidViewModelFactory，它内部是通过反射来创建具体的ViewModel*/ if (factory == null) &#123; factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; /*** * 利用HolderFragment来关联生命周期并使用HolderFragment中的ViewModelStore的HashMap存储ViewModel * AndroidViewModelFactory创建ViewModel */ return new ViewModelProvider(ViewModelStores.of(activity), factory); &#125;&#125; 创建使用ViewModel12//传入对应的上下文 即：数据retain的宿主NetDemoViewModel netDemoViewModel = ViewModelProviders.of(fragment/activity).get(NetDemoViewModel.class); ViewModel 的存在是依赖 Activity 或者 Fragment的，不管你在什么地方获取ViewModel ，只要你用的是相同的Activity 或者 Fragment，那么获取到的ViewModel将是同一个 (前提是key值是一样的)，所以ViewModel 有数据共享的作用。 ViewModel是怎么创建的？看上面的获取viewmodel的对象的链式调用的方法可以理解成 分为两步1234/*****第一步:根据Activity或者Fragment获得ViewModelProvider****/ViewModelProviders viewModelProvider = ViewModelProviders.of(fragment/activity);/*****第二步:使用ViewModelProvider反射创建需要的ViewModel****/NetDemoViewModel netDemoViewModel = viewModelProvider.get(NetDemoViewModel.class); 第一步获得的源代码： 123456789101112131415161718192021/** * Creates a &#123;@link ViewModelProvider&#125;, which retains ViewModels while a scope of given * &#123;@code fragment&#125; is alive. More detailed explanation is in &#123;@link ViewModel&#125;. * &lt;p&gt; * It uses the given &#123;@link Factory&#125; to instantiate new ViewModels. * * @param fragment a fragment, in whose scope ViewModels should be retained * @param factory a &#123;@code Factory&#125; to instantiate new ViewModels * @return a ViewModelProvider instance */@NonNull@MainThreadpublic static ViewModelProvider of(@NonNull Fragment fragment, @Nullable Factory factory) &#123; Application application = checkApplication(checkActivity(fragment)); if (factory == null) &#123; /**********获得AndroidViewModelFactory ( 内部是单例的 )*******/ factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application); &#125; /*****创建一个ViewModelProvider( 传入的两个参数是重点 )*****/ return new ViewModelProvider(ViewModelStores.of(fragment), factory);&#125; 上面的两步，获得AndroidViewModelFactory ，AndroidViewModelFactory其实是ViewModelProvider的静态内部类，看调用方式就知道是一个单例的，就是应用里面只有一个单例的 AndroidViewModelFactory存在，看源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public static class AndroidViewModelFactory extends ViewModelProvider.NewInstanceFactory &#123; private static AndroidViewModelFactory sInstance; /** * Retrieve a singleton instance of AndroidViewModelFactory. * 获得AndroidViewModelFactory 单例 * @param application an application to pass in &#123;@link AndroidViewModel&#125; * @return A valid &#123;@link AndroidViewModelFactory&#125; */ @NonNull public static AndroidViewModelFactory getInstance(@NonNull Application application) &#123; if (sInstance == null) &#123; sInstance = new AndroidViewModelFactory(application); &#125; return sInstance; &#125; private Application mApplication; /** * Creates a &#123;@code AndroidViewModelFactory&#125; * * @param application an application to pass in &#123;@link AndroidViewModel&#125; */ public AndroidViewModelFactory(@NonNull Application application) &#123; mApplication = application; &#125; /******其实这里就是创建ViewModel的关键地方，根据给出的Class反射创建需要的ViewModel*******/ @NonNull @Override public &lt;T extends ViewModel&gt; T create(@NonNull Class&lt;T&gt; modelClass) &#123; if (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123; //noinspection TryWithIdenticalCatches try &#123; return modelClass.getConstructor(Application.class).newInstance(mApplication); &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException(&quot;Cannot create an instance of &quot; + modelClass, e); &#125; &#125; return super.create(modelClass); &#125; &#125; 看到这里,全局的AndroidViewModelFactory工具类，作用其实就是反射创建我们想要的类ViewModel。获得到的单例AndroidViewModelFactory是创建ViewModelProvider的第二个参数。第一个参数是这样的： ViewModelStores.of(activity)看源码1234567891011121314151617181920212223public class ViewModelStores &#123; private ViewModelStores() &#123; &#125; /** * Returns the &#123;@link ViewModelStore&#125; of the given activity. * * @param activity an activity whose &#123;@code ViewModelStore&#125; is requested * @return a &#123;@code ViewModelStore&#125; */ @NonNull @MainThread public static ViewModelStore of(@NonNull FragmentActivity activity) &#123; //如果你的Activity实现了ViewModelStoreOwner接口具备了提供 //ViewModelStore 的功能就直接获取返回，通常我们的Activity都不会去实现这个功能 if (activity instanceof ViewModelStoreOwner) &#123; return ((ViewModelStoreOwner) activity).getViewModelStore(); &#125; //系统为你的Activity添加一个具有提供ViewModelStore 的holderFragment return holderFragmentFor(activity).getViewModelStore(); &#125;&#125; 其实理解ViewModelStore就可以解释ViewModel的存储，理解了holderFragmentFor(activity).getViewModelStore() 就可解释ViewModel为什么可以在Activity配置发生变化的情况下人不销毁。以上源码分析可以明白： AndroidViewModelFactory在正常情况下是全局单例只有一个，只是一个反射创建对象的工具类。 ViewModelProvider是每次获取创建ViewModel的时候都会创建一个新的。 ViewModelStore是每一个Activity或者Fragment都有一个。 第二部分:12345678@MainThreadpublic &lt;T extends ViewModel&gt; T get(@NonNull Class&lt;T&gt; modelClass) &#123; String canonicalName = modelClass.getCanonicalName(); if (canonicalName == null) &#123; throw new IllegalArgumentException(&quot;Local and anonymous classes can not be ViewModels&quot;); &#125; return get(DEFAULT_KEY + &quot;:&quot; + canonicalName, modelClass);&#125; 用 DEFAULT_KEY 和 类名组成一个key值去获取; 12345678910111213141516171819202122232425262728293031323334/** * Returns an existing ViewModel or creates a new one in the scope (usually, a fragment or * an activity), associated with this &#123;@code ViewModelProvider&#125;. * &lt;p&gt; * The created ViewModel is associated with the given scope and will be retained * as long as the scope is alive (e.g. if it is an activity, until it is * finished or process is killed). * * @param key The key to use to identify the ViewModel. * @param modelClass The class of the ViewModel to create an instance of it if it is not * present. * @param &lt;T&gt; The type parameter for the ViewModel. * @return A ViewModel that is an instance of the given type &#123;@code T&#125;. */ @NonNull @MainThread public &lt;T extends ViewModel&gt; T get(@NonNull String key, @NonNull Class&lt;T&gt; modelClass) &#123; ViewModel viewModel = mViewModelStore.get(key); if (modelClass.isInstance(viewModel)) &#123; //noinspection unchecked return (T) viewModel; &#125; else &#123; //noinspection StatementWithEmptyBody if (viewModel != null) &#123; // TODO: log a warning. &#125; &#125; viewModel = mFactory.create(modelClass); mViewModelStore.put(key, viewModel); //noinspection unchecked return (T) viewModel; &#125; 代码很简单，流程如下: 先从mViewModelStore中使用key去获取ViewModel, mViewModelStore中是使用HashMap去存储一个Activity或者Fragment的ViewModel的。如果获取到就返回。 没获取到就使用单例mFactory的create方法反射创建ViewModel,create方法的代码在上面贴出来了。 使用Key存入mViewModelStore 并返回。 也就是创建一个ViewModelProvider，使用ViewModelProvider内部的全局单例AndroidViewModelFactory来反射创建 ViewModel,并把创建的ViewModel存入传入的ViewModelStore中. ViewModel是怎么存储12345678910111213141516171819202122232425public class ViewModelStore &#123; private final HashMap&lt;String, ViewModel&gt; mMap = new HashMap&lt;&gt;(); final void put(String key, ViewModel viewModel) &#123; ViewModel oldViewModel = mMap.put(key, viewModel); if (oldViewModel != null) &#123; oldViewModel.onCleared(); &#125; &#125; final ViewModel get(String key) &#123; return mMap.get(key); &#125; /** * Clears internal storage and notifies ViewModels that they are no longer used. */ public final void clear() &#123; for (ViewModel vm : mMap.values()) &#123; vm.onCleared(); &#125; mMap.clear(); &#125;&#125; 就是一个 HashMap用存储ViewModel。提供get,put,clear三个方法。 ViewModelStore是每一个Activity或者Fragment都有一个的，当Activity或者Fragment销毁的时候就会调用clear方法了。 通过上面看源码: ViewModelStore被谁创建，被谁持有？被HolderFragment创建和持有！ HolderFragment跟我们的Activity或者Fragment有什么关系？当我们要给Activity或者Fragment创建ViewModel的时候，系统就会为Activity或者Fragment添加一个HolderFragment，HolderFragment中会创建持有一个ViewModelStore。 HolderFragment怎么创建怎么被添加？new ViewModelProvider(ViewModelStores.of(activity), factory);//上面有分析如何创建为什么都添加一个HolderFragment？1234//HolderFragment架造public HolderFragment() &#123; setRetainInstance(true);&#125; setRetainInstance(boolean) 是Fragment中的一个方法。将这个方法设置为true就可以使当前Fragment在Activity重建时存活下来, 如果不设置或者设置为 false, 当前 Fragment 会在 Activity 重建时同样发生重建, 以至于被新建的对象所替代。在setRetainInstance(boolean)为true的 Fragment （就是HolderFragment）中放一个专门用于存储ViewModel的Map, 这样Map中所有的ViewModel都会幸免于Activity的配置改变导致的重建，让需要创建ViewModel的Activity, Fragment都绑定一个这样的Fragment（就是HolderFragment）, 将ViewModel存放到这个 Fragment 的 Map 中, ViewModel 组件就这样实现了。 总结1.ViewModel 以键值对的形式存在Activity或者Fragment的HolderFragment的ViewModelStore的HashMap中。2.一个Activity或者Fragment可以有很多个ViewModel。3.一个Activity或者Fragment只会有一个HolderFragment。4.Activity或者Fragment的HolderFragment会保存在全局单例的HolderFragmentManager的HashMap中，在Activity或者Fragment销毁的时候会移除HashMap中对应的value。5.因为ViewModel是以Activity或者Fragment为存在基础，所以ViewModel可以在当前Activity和Fragment中实现数据共享，前提是传入相同的key值。所以ViewModel 主要就两个功能 第一个功能可以使 ViewModel 以及 ViewModel 中的数据在屏幕旋转或配置更改引起的 Activity 重建时存活下来, 重建后数据可继续使用。 第二个功能可以帮助开发者轻易实现 Fragment 与 Fragment 之间, Activity 与 Fragment 之间的通讯以及共享数据]]></content>
      <categories>
        <category>android技术文档</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ReactNative分享01]]></title>
    <url>%2F2018%2F06%2F14%2FRN-001%2F</url>
    <content type="text"><![CDATA[哪些应用使用了RN https://facebook.github.io/react-native/showcase.html 如何快速体验RN App 应用市场google play 、AppStore下载 ，推荐FaceBook F8大会App，搜索’F8’ 下载expo https://expo.io/ (推荐Android平台) ,(对expo的简单说明 https://zhuanlan.zhihu.com/p/27643105) github下载demo运行或者按官方文档配置环境运行 入门资料 官方文档 https://facebook.github.io/react-native/ 中文站 https://reactnative.cn/ Youtube 搜索ReactNative 第三方组件推荐 GitHub源码阅读chrome插件 ：Octotree 方便直接查看代码结构 搜索网站: https://js.coach/ https://github.com/jondot/awesome-react-native …]]></content>
      <categories>
        <category>React Native</category>
      </categories>
      <tags>
        <tag>React Native</tag>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写第一篇hexo博客]]></title>
    <url>%2F2018%2F06%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[在准备写博客之前可阅读一下简单教程 须知 本站博客使用hexo搭建，博客相关资源存在 https://github.com/T3Team/T3Team.github.io 上。 hexo分支为默认分支，存放hexo网站资源 master分支存放静态文件 初始化/恢复重装电脑后，或者在其它电脑上想修改博客： 安装 git； 安装 Nodejs 和 npm； 使用 git clone git@github.com:T3Team/T3Team.github.io.git 将仓库拷贝至本地； 在文件夹内执行以下命令 npm install hexo-cli -g、npm install、npm install hexo-deployer-git。 执行 hexo g 、hexo s 然后打开浏览器，输入地址http://localhost:4000/ ,即可看到效果 新建文章命令方式1$ hexo new test //test为文章名 .md文件头部会自动生成如下内容 title 文章标题 date 文章创建时间 author 作者，不填则显示默认值（本博客配置为T3team） tags 标签 categories 文章分类 1234567---title: testdate: 2018/6/14 17:10:00author: tags: categories: --- 本文头部参数如下 1234567891011---title: 如何写第一篇hexo博客date: 2018/6/14 17:10:00author: TFskytags: - hexo - 教程categories: - hexo - 教程--- 此时会在source/_posts目录下生成test.md文件，输入些许内容，然后保存. 生成下，看看效果 123$ hexo clean$ hexo g$ hexo s 访问 localhost:4000 即可 直接方式在 source/_posts/下新建一个.md文件也可 发布文章在本地对博客修改（包括修改主题样式、发布新文章等）后： 依次执行 git add、git commit -m &quot;xxxx&quot; (简单的描述下信息) 和 git push origin hexo 来提交 hexo 网站源文件； 执行 hexo g -d 生成静态网页部署至 Github 上。 相关参考文章: Hexo官方文档 Hexo 博客搭建指南 Hexo博客备份]]></content>
      <categories>
        <category>教程 - hexo</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
